// Code generated by protoc-gen-go. DO NOT EDIT.
// source: logging.proto

package rpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ReadLogsRequest struct {
}

func (m *ReadLogsRequest) Reset()                    { *m = ReadLogsRequest{} }
func (m *ReadLogsRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadLogsRequest) ProtoMessage()               {}
func (*ReadLogsRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type ReadLogsResponse struct {
	// entry is an emitted log entry. It is missing for an initial
	// ReadLogsResponse to indicate success of subscription.
	Entry *LogEntry `protobuf:"bytes,1,opt,name=entry" json:"entry,omitempty"`
}

func (m *ReadLogsResponse) Reset()                    { *m = ReadLogsResponse{} }
func (m *ReadLogsResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadLogsResponse) ProtoMessage()               {}
func (*ReadLogsResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ReadLogsResponse) GetEntry() *LogEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

type LogEntry struct {
	Msg string `protobuf:"bytes,1,opt,name=msg" json:"msg,omitempty"`
}

func (m *LogEntry) Reset()                    { *m = LogEntry{} }
func (m *LogEntry) String() string            { return proto.CompactTextString(m) }
func (*LogEntry) ProtoMessage()               {}
func (*LogEntry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *LogEntry) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func init() {
	proto.RegisterType((*ReadLogsRequest)(nil), "tast.core.ReadLogsRequest")
	proto.RegisterType((*ReadLogsResponse)(nil), "tast.core.ReadLogsResponse")
	proto.RegisterType((*LogEntry)(nil), "tast.core.LogEntry")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Logging service

type LoggingClient interface {
	// ReadLogs subscribes to logs emitted by gRPC services.
	// At the beginning of the call, one ReadLogsResponse with empty entry is
	// sent to indicate success of subscription. Afterwards ReadLogsResponse is
	// sent back as a stream as logs are emitted. The response stream is closed
	// when the client closes the request stream or any error occurs.
	// At most one client can have an active call of this method at a time.
	ReadLogs(ctx context.Context, opts ...grpc.CallOption) (Logging_ReadLogsClient, error)
}

type loggingClient struct {
	cc *grpc.ClientConn
}

func NewLoggingClient(cc *grpc.ClientConn) LoggingClient {
	return &loggingClient{cc}
}

func (c *loggingClient) ReadLogs(ctx context.Context, opts ...grpc.CallOption) (Logging_ReadLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Logging_serviceDesc.Streams[0], c.cc, "/tast.core.Logging/ReadLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &loggingReadLogsClient{stream}
	return x, nil
}

type Logging_ReadLogsClient interface {
	Send(*ReadLogsRequest) error
	Recv() (*ReadLogsResponse, error)
	grpc.ClientStream
}

type loggingReadLogsClient struct {
	grpc.ClientStream
}

func (x *loggingReadLogsClient) Send(m *ReadLogsRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *loggingReadLogsClient) Recv() (*ReadLogsResponse, error) {
	m := new(ReadLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for Logging service

type LoggingServer interface {
	// ReadLogs subscribes to logs emitted by gRPC services.
	// At the beginning of the call, one ReadLogsResponse with empty entry is
	// sent to indicate success of subscription. Afterwards ReadLogsResponse is
	// sent back as a stream as logs are emitted. The response stream is closed
	// when the client closes the request stream or any error occurs.
	// At most one client can have an active call of this method at a time.
	ReadLogs(Logging_ReadLogsServer) error
}

func RegisterLoggingServer(s *grpc.Server, srv LoggingServer) {
	s.RegisterService(&_Logging_serviceDesc, srv)
}

func _Logging_ReadLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LoggingServer).ReadLogs(&loggingReadLogsServer{stream})
}

type Logging_ReadLogsServer interface {
	Send(*ReadLogsResponse) error
	Recv() (*ReadLogsRequest, error)
	grpc.ServerStream
}

type loggingReadLogsServer struct {
	grpc.ServerStream
}

func (x *loggingReadLogsServer) Send(m *ReadLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *loggingReadLogsServer) Recv() (*ReadLogsRequest, error) {
	m := new(ReadLogsRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Logging_serviceDesc = grpc.ServiceDesc{
	ServiceName: "tast.core.Logging",
	HandlerType: (*LoggingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ReadLogs",
			Handler:       _Logging_ReadLogs_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "logging.proto",
}

func init() { proto.RegisterFile("logging.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 188 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xcd, 0xc9, 0x4f, 0x4f,
	0xcf, 0xcc, 0x4b, 0xd7, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x2c, 0x49, 0x2c, 0x2e, 0xd1,
	0x4b, 0xce, 0x2f, 0x4a, 0x55, 0x12, 0xe4, 0xe2, 0x0f, 0x4a, 0x4d, 0x4c, 0xf1, 0xc9, 0x4f, 0x2f,
	0x0e, 0x4a, 0x2d, 0x2c, 0x4d, 0x2d, 0x2e, 0x51, 0xb2, 0xe5, 0x12, 0x40, 0x08, 0x15, 0x17, 0xe4,
	0xe7, 0x15, 0xa7, 0x0a, 0x69, 0x72, 0xb1, 0xa6, 0xe6, 0x95, 0x14, 0x55, 0x4a, 0x30, 0x2a, 0x30,
	0x6a, 0x70, 0x1b, 0x09, 0xeb, 0xc1, 0x4d, 0xd0, 0xf3, 0xc9, 0x4f, 0x77, 0x05, 0x49, 0x05, 0x41,
	0x54, 0x28, 0xc9, 0x70, 0x71, 0xc0, 0x84, 0x84, 0x04, 0xb8, 0x98, 0x73, 0x8b, 0xd3, 0xc1, 0x9a,
	0x38, 0x83, 0x40, 0x4c, 0xa3, 0x10, 0x2e, 0x76, 0x1f, 0x88, 0x5b, 0x84, 0x3c, 0xb9, 0x38, 0x60,
	0xf6, 0x08, 0x49, 0x21, 0x19, 0x88, 0xe6, 0x1e, 0x29, 0x69, 0xac, 0x72, 0x10, 0x87, 0x29, 0x31,
	0x68, 0x30, 0x1a, 0x30, 0x3a, 0x89, 0x46, 0x09, 0x27, 0x67, 0x14, 0xe5, 0xe7, 0x66, 0x96, 0xe6,
	0xe6, 0x17, 0xeb, 0x83, 0x94, 0xeb, 0x17, 0x15, 0x24, 0x27, 0xb1, 0x81, 0xbd, 0x6b, 0x0c, 0x08,
	0x00, 0x00, 0xff, 0xff, 0xd5, 0xa9, 0x93, 0xa5, 0xff, 0x00, 0x00, 0x00,
}
