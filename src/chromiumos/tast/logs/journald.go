// Copyright 2019 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package logs

import (
	"compress/gzip"
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"regexp"
)

// journaldCursorRegexp parses output from a journalctl --show-cursor command. Example output:
// -- cursor: s=bfd03b7e4c464cc09b43e1843880f9ee;i=a5eab;b=cdd933be...
var journaldCursorRegexp = regexp.MustCompile(`^-- cursor:\s+(\S+)`)

// GetJournaldCursor returns a journald cursor to the current tip of the logs.
// The return cursor can later be passed to WriteJournaldLogs.
func GetJournaldCursor(ctx context.Context) (string, error) {
	cmd := exec.CommandContext(ctx, "journalctl", "-n0", "--show-cursor", "-q")
	cmd.Env = append(os.Environ(), "PAGER=cat") // seems to use /usr/bin/less by default
	out, err := cmd.Output()
	if err != nil {
		return "", err
	}
	m := journaldCursorRegexp.FindSubmatch(out)
	if m == nil {
		return "", fmt.Errorf("failed to find %q in %q", journaldCursorRegexp, out)
	}
	return string(m[1]), nil
}

// JournaldFormat is a format for journald log entries.
type JournaldFormat int

const (
	// JournaldCompact corresponds to human-readable single-line log entries.
	JournaldCompact JournaldFormat = iota
	// JournaldExport corresponds to journalctl's "-o export" multiline format that preserves metdata.
	// The data is additionally gzip-compressed.
	JournaldExport
)

// WriteJournaldLogs writes all journald log entries generated after cursor to w using fm.
// cursor should have been generated by an earlier call to GetJournaldCursor.
func WriteJournaldLogs(ctx context.Context, w io.Writer, cursor string, fm JournaldFormat) error {
	args := []string{"--after-cursor=" + cursor}
	if fm == JournaldExport {
		args = append(args, "-o", "export")
	}
	cmd := exec.CommandContext(ctx, "journalctl", args...)

	var ww io.WriteCloser // wraps w; may be nil
	if fm == JournaldExport {
		ww = gzip.NewWriter(w)
		cmd.Stdout = ww
	} else {
		cmd.Stdout = w
	}

	err := cmd.Run()

	// If the writer was wrapped, close the wrapper to flush data.
	if ww != nil {
		if cerr := ww.Close(); cerr != nil && err == nil {
			err = cerr
		}
	}

	return err
}
