// Code generated by protoc-gen-go. DO NOT EDIT.
// source: test/plan/v1/plan.proto

package plan

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	api "go.chromium.org/chromiumos/config/go/api"
	lab "go.chromium.org/chromiumos/infra/proto/go/lab"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A set of known test plans.
//
// In practice, a complete specification of all known plans may consist of
// multiple Specification instances. In that case the plan names MUST be unique
// across different Specification instances.
type Specification struct {
	Plans                []*Plan  `protobuf:"bytes,1,rep,name=plans,proto3" json:"plans,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Specification) Reset()         { *m = Specification{} }
func (m *Specification) String() string { return proto.CompactTextString(m) }
func (*Specification) ProtoMessage()    {}
func (*Specification) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{0}
}

func (m *Specification) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Specification.Unmarshal(m, b)
}
func (m *Specification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Specification.Marshal(b, m, deterministic)
}
func (m *Specification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Specification.Merge(m, src)
}
func (m *Specification) XXX_Size() int {
	return xxx_messageInfo_Specification.Size(m)
}
func (m *Specification) XXX_DiscardUnknown() {
	xxx_messageInfo_Specification.DiscardUnknown(m)
}

var xxx_messageInfo_Specification proto.InternalMessageInfo

func (m *Specification) GetPlans() []*Plan {
	if m != nil {
		return m.Plans
	}
	return nil
}

// A Plan fully specifies a Test Platform end-user's coverage needs.
//
// Plans SHOULD associate platform software and Device Under Test condition
// coverage rules with tests that exercise those components. Plans MUST be used
// in the Test Platform request API. Other Test Lab Environments may use plans
// to ease interoperation with the Test Platform.
type Plan struct {
	// A globally unique test plan name.
	//
	// MUST be valid resource name per https://aip.dev/122.
	//
	// Pattern: plans/{plan}
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Each test plan unit specifies a particular set of tests to be run to meet
	// specific conditions.
	Units                []*Unit  `protobuf:"bytes,2,rep,name=units,proto3" json:"units,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}
func (*Plan) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{1}
}

func (m *Plan) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Plan.Unmarshal(m, b)
}
func (m *Plan) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Plan.Marshal(b, m, deterministic)
}
func (m *Plan) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Plan.Merge(m, src)
}
func (m *Plan) XXX_Size() int {
	return xxx_messageInfo_Plan.Size(m)
}
func (m *Plan) XXX_DiscardUnknown() {
	xxx_messageInfo_Plan.DiscardUnknown(m)
}

var xxx_messageInfo_Plan proto.InternalMessageInfo

func (m *Plan) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Plan) GetUnits() []*Unit {
	if m != nil {
		return m.Units
	}
	return nil
}

// Specifies a particular set of tests to be run to meet specific conditions.
type Unit struct {
	// A globally unique test plan unit name.
	//
	// MUST be valid resource name per https://aip.dev/122.
	//
	// Pattern: plans/{plan}/units/{unit}
	//   where {plan} is the parent Plan of this Unit.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Selects tests to include in this test plan unit.
	TestCondition *TestCondition `protobuf:"bytes,2,opt,name=test_condition,json=testCondition,proto3" json:"test_condition,omitempty"`
	// Selects the set of Devices Under Test that satisfy the coverage
	// requirements of this test plan unit.
	DutCoverageCondition *DUTCoverageCondition `protobuf:"bytes,3,opt,name=dut_coverage_condition,json=dutCoverageCondition,proto3" json:"dut_coverage_condition,omitempty"`
	// Chrome OS platform software covered by this test plan.
	//
	// Test Platform requests may optionally include a reference to platform
	// software to be tested via the test plan. For such requests, Test Platform
	// MUST only execute test plan units that have non-trivial coverage of the
	// referenced platform software. Unrelated test plan units MUST be skipped.
	//
	// A typical example is presubmit testing: When testing a change to the
	// network manager, it may be desirable to only run test plan units that
	// are known to exercise the network manager.
	//
	// For a test plan unit with no `code_coverage` specified, Test Platform MUST
	// assume coverage of all platform software (i.e., this test plan unit MUST
	// never be skipped for code coverage considerations).
	CodeCoverage         *CodeCoverage `protobuf:"bytes,4,opt,name=code_coverage,json=codeCoverage,proto3" json:"code_coverage,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Unit) Reset()         { *m = Unit{} }
func (m *Unit) String() string { return proto.CompactTextString(m) }
func (*Unit) ProtoMessage()    {}
func (*Unit) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{2}
}

func (m *Unit) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Unit.Unmarshal(m, b)
}
func (m *Unit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Unit.Marshal(b, m, deterministic)
}
func (m *Unit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Unit.Merge(m, src)
}
func (m *Unit) XXX_Size() int {
	return xxx_messageInfo_Unit.Size(m)
}
func (m *Unit) XXX_DiscardUnknown() {
	xxx_messageInfo_Unit.DiscardUnknown(m)
}

var xxx_messageInfo_Unit proto.InternalMessageInfo

func (m *Unit) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Unit) GetTestCondition() *TestCondition {
	if m != nil {
		return m.TestCondition
	}
	return nil
}

func (m *Unit) GetDutCoverageCondition() *DUTCoverageCondition {
	if m != nil {
		return m.DutCoverageCondition
	}
	return nil
}

func (m *Unit) GetCodeCoverage() *CodeCoverage {
	if m != nil {
		return m.CodeCoverage
	}
	return nil
}

// Selects the test.metadata.Test to include in a test plan unit.
type TestCondition struct {
	// A Common Expression Language (CEL) expression to specify test conditions.
	//
	// The full CEL spec can be found at https://github.com/google/cel-spec.
	// Test Platform MUST interpret `expression` in the scope of
	// `test.plan.TestCondition.Scope` defined below.
	//
	// ## Examples
	//
	// Typical instructive examples of expressions are:
	//
	// - Tauto dummy tests
	//     "suite:dummy" in scope.attributes
	// - Tast's crosbolt tests
	//     !("disabled" in scope.attributes)
	//     && "group:crosbolt" in scope.attributes
	//     && "crosbolt_perbuild" in scope.attributes
	// - network Tauto tests, selected by name
	//     scope.test.startsWith("network_")
	//
	// ## CEL support
	//
	// All standard CEL syntax, macros and functions MUST be supported.
	//
	// ### Evaluation context
	//
	// In general, a CEL expression must be evaluated in some context that
	// provides the basic bindings for name resolution.
	//
	// In this case, `expression` MUST be evaluated in a context that contains
	//
	// - A variable 'scope' of type TestCondition.Scope. This variable contains
	//   the information about a particular Test being tested for
	//   inclusion in the test plan unit via `expression`.
	// - Protobuf definitions in this git project (i.e., rooted at infra/proto/).
	Expression           string   `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestCondition) Reset()         { *m = TestCondition{} }
func (m *TestCondition) String() string { return proto.CompactTextString(m) }
func (*TestCondition) ProtoMessage()    {}
func (*TestCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{3}
}

func (m *TestCondition) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TestCondition.Unmarshal(m, b)
}
func (m *TestCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TestCondition.Marshal(b, m, deterministic)
}
func (m *TestCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCondition.Merge(m, src)
}
func (m *TestCondition) XXX_Size() int {
	return xxx_messageInfo_TestCondition.Size(m)
}
func (m *TestCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCondition.DiscardUnknown(m)
}

var xxx_messageInfo_TestCondition proto.InternalMessageInfo

func (m *TestCondition) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

type TestCondition_Scope struct {
	// Name of the test as specified in test.metadata.Test.name
	Test string `protobuf:"bytes,1,opt,name=test,proto3" json:"test,omitempty"`
	// The test attribute name as specified in the test.metadata.Attribute.name
	//
	// attributes are populated from test.metadata.Test.attributes.
	Attributes           []string `protobuf:"bytes,2,rep,name=attributes,proto3" json:"attributes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TestCondition_Scope) Reset()         { *m = TestCondition_Scope{} }
func (m *TestCondition_Scope) String() string { return proto.CompactTextString(m) }
func (*TestCondition_Scope) ProtoMessage()    {}
func (*TestCondition_Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{3, 0}
}

func (m *TestCondition_Scope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TestCondition_Scope.Unmarshal(m, b)
}
func (m *TestCondition_Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TestCondition_Scope.Marshal(b, m, deterministic)
}
func (m *TestCondition_Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestCondition_Scope.Merge(m, src)
}
func (m *TestCondition_Scope) XXX_Size() int {
	return xxx_messageInfo_TestCondition_Scope.Size(m)
}
func (m *TestCondition_Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_TestCondition_Scope.DiscardUnknown(m)
}

var xxx_messageInfo_TestCondition_Scope proto.InternalMessageInfo

func (m *TestCondition_Scope) GetTest() string {
	if m != nil {
		return m.Test
	}
	return ""
}

func (m *TestCondition_Scope) GetAttributes() []string {
	if m != nil {
		return m.Attributes
	}
	return nil
}

// Selects sets of Devices Under Test to run the tests on in a test plan unit.
type DUTCoverageCondition struct {
	// A Common Expression Language (CEL) expression to specify set of DUTs that
	// provide the necessary coverage.
	//
	// Test Platform MUST interpret `expression` in the scope of the
	// protobuf message DUTCoverageCondition.Scope defined below. In summary, the
	// expression allows selection of a set of Devices Under Test that provide the
	// necessary coverage - Test Platform will determine a set of devices that
	// satisfies `expression` and execute the tests in the plan on all selected
	// devices.
	// - Platform may freely choose the exact set of devices used if `expression`
	//   is satisfiable by more than one set.
	// - Different tests in the plan may be executed on different sets of devices,
	//   as long as they all satisfy `expression` individually.
	//
	// The full CEL spec can be found at https://github.com/google/cel-spec.
	// This API only supports a sub-set of the CEL features as described here.
	// Test Platform MUST validate the expression and reject use of unsupported
	// features.
	//
	// TODO(crbug.com/1051689) Add reference to the metadata validator package.
	//
	// ## Examples
	//
	// Typical instructive examples of expressions are:
	//
	// - Constraints: All pre-F20 plans only specify constraints on what devices
	//   may be used, e.g.:
	//    - Run each test on one DUT with model 'nautilus'.
	//        TODO(pprabhu, shapiroc): Need a way to specify model for migration.
	//        duts.all(dut, dut.id.model_id.value = 'nautilus') && size(duts) == 1
	//    - Run each test on one DUT with a stylus.
	//        (duts.all(dut, dut.hardware_features.stylus
	//                       == dut.hardware_features.PRESENT))
	//         && size(duts) == 1)
	//  - Fanout (not yet supported): In addition to constraints, the
	//    plan may want to ensure coverage across some device features.
	//    TODO(pprabhu) This is an instructive example. We can't say what arch
	//    yet.
	//    - Run each test on one x86 and ARM DUT with a specific camera.
	//        (duts.all(dut, dut.hardware_toplogy.camera.id != "gomoe")
	//         && duts.exist(dut,
	//                       dut.cpu = dut.Config.Architecture.X86)
	//         && duts.exist(dut,
	//                       dut.cpu = dut.Config.Architecture.ARM))
	//      Note that this expression does not have a clause for size(duts). Thus
	//      Test Platform may satisfy this expression by running the test on more
	//      than two DUTs. This behaviour can be unexpected, especially if the
	//      plan fails due to an error on test execution on one of the selected
	//      devices, even though it passed on other devices in the set such that
	//      the expression was satsifed by the passing subset. Selection of a
	//      minimal set of devices to run the plan is best effort.
	//
	// Currently, only single-DUT constraints are supported by the Test Platform.
	// i.e., `expression` MUST be of the form:
	//   duts.all(DUT_SELECTOR) && size(duts) == 1
	// where DUT_SELECTOR is an expression that does not refer to `duts`.
	// This restriction will be lifted as this API matures.
	//
	// ## CEL support
	//
	// Current support for `expression` evaluation is very restricted due to
	// limitations in the scheduling platform used by Test Platform. Specifying
	// the conditions in CEL will allow gradual lifting of support restrictions.
	//
	// As this API matures, features will be added to the scheduling
	// infrastructure of Test Platform and restrictions here will be lifted based
	// on requirements collected from test plan authors. See milestones in
	// go/cros-f20-plan for expected feature iterations.
	//
	// ### Evaluation context
	//
	// In general, a CEL expression must be evaluated in some context that
	// provides the basic bindings for name resolution.
	//
	// In this case, `expression` MUST be evaluated in a context that contains
	//
	// - A variable 'scope' of type DUTCoverageCondition.Scope. This variable
	//   contains the information about the set of Devices Under Test being
	//   tested for acceptance via `expression`.
	// - Protobuf definitions in this git project (i.e., rooted at infra/proto/)
	//
	// ### Syntax
	//
	// See full syntax definition at
	// https://github.com/google/cel-spec/blob/master/doc/langdef.md#syntax
	//
	// CEL standard syntax allows expressions that evaluate to errors (e.g.,
	// syntax allows negation of lists, which has no semantics in CEL).
	// Thus, this spec does not attempt to restrict the syntax, but specifies what
	// operations are unsupported to aid metadata producers. Ultimately, the
	// reference metadata validator is the authority on what expressions are
	// allowed.
	//
	// Unsupported standard CEL semantics:
	//   - Binary arithmetic operations
	//     e.g.: +, *, /, % ...
	//   - Relational Operators beyond (in)equality are not supported.
	//     e.g.: (>, <, >=, <= ...)
	//   - Logical OR in expressions is not supported.
	//     e.g.: (a || b), !(a && b) ...
	//
	// ### Macros
	//
	// See full macro definition at
	// https://github.com/google/cel-spec/blob/master/doc/langdef.md#macros
	//
	// Supported macros: has(), e.all()
	// Unsupported macros: e.exists(), e.exists_one(), e.map(), e.filter()
	//
	// ### Standard Functions
	//
	// See full list of standard definitions at
	// https://github.com/google/cel-spec/blob/master/doc/langdef.md#standard-definitions
	//
	// Most standard functions are not supported.
	//
	// - Supported operators: !_, -_, _!=_, _&&_, _=_, _[_]
	//   - All other operators are not supported.
	// - All other standard functions are not supported. In particular take note:
	//   - size() is not supported, *except in the mandatory top-level size(duts)
	//     expression*.
	//   - string functions like endsWith() and contains() are not supported.
	//   - type conversions like int() and string() are not supported.
	//   - reflection with type(), null_type() and dyn() is not supported.
	Expression           string   `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DUTCoverageCondition) Reset()         { *m = DUTCoverageCondition{} }
func (m *DUTCoverageCondition) String() string { return proto.CompactTextString(m) }
func (*DUTCoverageCondition) ProtoMessage()    {}
func (*DUTCoverageCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{4}
}

func (m *DUTCoverageCondition) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DUTCoverageCondition.Unmarshal(m, b)
}
func (m *DUTCoverageCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DUTCoverageCondition.Marshal(b, m, deterministic)
}
func (m *DUTCoverageCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DUTCoverageCondition.Merge(m, src)
}
func (m *DUTCoverageCondition) XXX_Size() int {
	return xxx_messageInfo_DUTCoverageCondition.Size(m)
}
func (m *DUTCoverageCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_DUTCoverageCondition.DiscardUnknown(m)
}

var xxx_messageInfo_DUTCoverageCondition proto.InternalMessageInfo

func (m *DUTCoverageCondition) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

// `expression` above is interpreted in the scope of the following message.
// The scope contains the features for a set of Devices Under Test that will
// be used to satisfy the plan.
type DUTCoverageCondition_Scope struct {
	// Set of Devices Under Test to be used to satisfy the test plan unit.
	Duts                 []*DUTCoverageCondition_Scope_DUT `protobuf:"bytes,1,rep,name=duts,proto3" json:"duts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *DUTCoverageCondition_Scope) Reset()         { *m = DUTCoverageCondition_Scope{} }
func (m *DUTCoverageCondition_Scope) String() string { return proto.CompactTextString(m) }
func (*DUTCoverageCondition_Scope) ProtoMessage()    {}
func (*DUTCoverageCondition_Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{4, 0}
}

func (m *DUTCoverageCondition_Scope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DUTCoverageCondition_Scope.Unmarshal(m, b)
}
func (m *DUTCoverageCondition_Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DUTCoverageCondition_Scope.Marshal(b, m, deterministic)
}
func (m *DUTCoverageCondition_Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DUTCoverageCondition_Scope.Merge(m, src)
}
func (m *DUTCoverageCondition_Scope) XXX_Size() int {
	return xxx_messageInfo_DUTCoverageCondition_Scope.Size(m)
}
func (m *DUTCoverageCondition_Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_DUTCoverageCondition_Scope.DiscardUnknown(m)
}

var xxx_messageInfo_DUTCoverageCondition_Scope proto.InternalMessageInfo

func (m *DUTCoverageCondition_Scope) GetDuts() []*DUTCoverageCondition_Scope_DUT {
	if m != nil {
		return m.Duts
	}
	return nil
}

// Device Under Test features relevant for test plan conditions.
type DUTCoverageCondition_Scope_DUT struct {
	// Configuration information about the lab deployment of the device.
	LabDut *lab.DeviceUnderTest `protobuf:"bytes,1,opt,name=lab_dut,json=labDut,proto3" json:"lab_dut,omitempty"`
	// The relationship between topology and features is described at
	// https://chromium.googlesource.com/chromiumos/config/+/master/proto/api/hardware_topology.md
	HardwareTopology     *api.HardwareTopology `protobuf:"bytes,2,opt,name=hardware_topology,json=hardwareTopology,proto3" json:"hardware_topology,omitempty"`
	HardwareFeatures     *api.HardwareFeatures `protobuf:"bytes,3,opt,name=hardware_features,json=hardwareFeatures,proto3" json:"hardware_features,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *DUTCoverageCondition_Scope_DUT) Reset()         { *m = DUTCoverageCondition_Scope_DUT{} }
func (m *DUTCoverageCondition_Scope_DUT) String() string { return proto.CompactTextString(m) }
func (*DUTCoverageCondition_Scope_DUT) ProtoMessage()    {}
func (*DUTCoverageCondition_Scope_DUT) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{4, 0, 0}
}

func (m *DUTCoverageCondition_Scope_DUT) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DUTCoverageCondition_Scope_DUT.Unmarshal(m, b)
}
func (m *DUTCoverageCondition_Scope_DUT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DUTCoverageCondition_Scope_DUT.Marshal(b, m, deterministic)
}
func (m *DUTCoverageCondition_Scope_DUT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DUTCoverageCondition_Scope_DUT.Merge(m, src)
}
func (m *DUTCoverageCondition_Scope_DUT) XXX_Size() int {
	return xxx_messageInfo_DUTCoverageCondition_Scope_DUT.Size(m)
}
func (m *DUTCoverageCondition_Scope_DUT) XXX_DiscardUnknown() {
	xxx_messageInfo_DUTCoverageCondition_Scope_DUT.DiscardUnknown(m)
}

var xxx_messageInfo_DUTCoverageCondition_Scope_DUT proto.InternalMessageInfo

func (m *DUTCoverageCondition_Scope_DUT) GetLabDut() *lab.DeviceUnderTest {
	if m != nil {
		return m.LabDut
	}
	return nil
}

func (m *DUTCoverageCondition_Scope_DUT) GetHardwareTopology() *api.HardwareTopology {
	if m != nil {
		return m.HardwareTopology
	}
	return nil
}

func (m *DUTCoverageCondition_Scope_DUT) GetHardwareFeatures() *api.HardwareFeatures {
	if m != nil {
		return m.HardwareFeatures
	}
	return nil
}

// Specifies platforms software covered by a test plan unit.
type CodeCoverage struct {
	// A Common Expression Language (CEL) expression to specify code coverage.
	//
	// The full CEL spec can be found at https://github.com/google/cel-spec.
	// Test Platform MUST interpret `expression` in the scope of
	// `test.plan.CodeCoverageCondition.Scope` defined below.
	//
	// ## Examples
	//
	// Typical instructive examples of expressions are:
	//
	// - Need to cover chromite changes
	//     scope.src_paths.exists(p, p.startsWith("chromite"))
	// - Need to cover chromite and autotest changes
	//     scope.src_paths.exists(p, [
	//         "src/third_party/autotest/files",
	//         "chromite"
	//       ].exists(s, p.startsWith(s)))
	// - Need to not cover changes to private overlays
	//     scope.src_paths.all(p, !p.contains("private-overlays"))
	//
	// ## CEL support
	//
	// All standard CEL syntax, macros and functions MUST be supported.
	//
	// ### Evaluation context
	//
	// In general, a CEL expression must be evaluated in some context that
	// provides the basic bindings for name resolution.
	//
	// In this case, `expression` MUST be evaluated in a context that contains
	//
	// - A variable 'scope' of type CodeCoverage.Scope. This variable contains
	//   the information about what platform software changes are intended to be
	//   tested by this test plan unit.
	// - Protobuf definitions in this git project (i.e., rooted at infra/proto/).
	Expression           string   `protobuf:"bytes,1,opt,name=expression,proto3" json:"expression,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CodeCoverage) Reset()         { *m = CodeCoverage{} }
func (m *CodeCoverage) String() string { return proto.CompactTextString(m) }
func (*CodeCoverage) ProtoMessage()    {}
func (*CodeCoverage) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{5}
}

func (m *CodeCoverage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CodeCoverage.Unmarshal(m, b)
}
func (m *CodeCoverage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CodeCoverage.Marshal(b, m, deterministic)
}
func (m *CodeCoverage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodeCoverage.Merge(m, src)
}
func (m *CodeCoverage) XXX_Size() int {
	return xxx_messageInfo_CodeCoverage.Size(m)
}
func (m *CodeCoverage) XXX_DiscardUnknown() {
	xxx_messageInfo_CodeCoverage.DiscardUnknown(m)
}

var xxx_messageInfo_CodeCoverage proto.InternalMessageInfo

func (m *CodeCoverage) GetExpression() string {
	if m != nil {
		return m.Expression
	}
	return ""
}

type CodeCoverage_Scope struct {
	// Covered paths (usually directories) in a typical checkout of the Chrome
	// OS source tree.
	//
	// Paths are relative to `repo` root. e.g., changes to the network manager
	// are covered by `src/platform2/shill`.
	SrcPaths             []string `protobuf:"bytes,1,rep,name=src_paths,json=srcPaths,proto3" json:"src_paths,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CodeCoverage_Scope) Reset()         { *m = CodeCoverage_Scope{} }
func (m *CodeCoverage_Scope) String() string { return proto.CompactTextString(m) }
func (*CodeCoverage_Scope) ProtoMessage()    {}
func (*CodeCoverage_Scope) Descriptor() ([]byte, []int) {
	return fileDescriptor_1a74b4d4119f628f, []int{5, 0}
}

func (m *CodeCoverage_Scope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CodeCoverage_Scope.Unmarshal(m, b)
}
func (m *CodeCoverage_Scope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CodeCoverage_Scope.Marshal(b, m, deterministic)
}
func (m *CodeCoverage_Scope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CodeCoverage_Scope.Merge(m, src)
}
func (m *CodeCoverage_Scope) XXX_Size() int {
	return xxx_messageInfo_CodeCoverage_Scope.Size(m)
}
func (m *CodeCoverage_Scope) XXX_DiscardUnknown() {
	xxx_messageInfo_CodeCoverage_Scope.DiscardUnknown(m)
}

var xxx_messageInfo_CodeCoverage_Scope proto.InternalMessageInfo

func (m *CodeCoverage_Scope) GetSrcPaths() []string {
	if m != nil {
		return m.SrcPaths
	}
	return nil
}

func init() {
	proto.RegisterType((*Specification)(nil), "test.plan.v1.Specification")
	proto.RegisterType((*Plan)(nil), "test.plan.v1.Plan")
	proto.RegisterType((*Unit)(nil), "test.plan.v1.Unit")
	proto.RegisterType((*TestCondition)(nil), "test.plan.v1.TestCondition")
	proto.RegisterType((*TestCondition_Scope)(nil), "test.plan.v1.TestCondition.Scope")
	proto.RegisterType((*DUTCoverageCondition)(nil), "test.plan.v1.DUTCoverageCondition")
	proto.RegisterType((*DUTCoverageCondition_Scope)(nil), "test.plan.v1.DUTCoverageCondition.Scope")
	proto.RegisterType((*DUTCoverageCondition_Scope_DUT)(nil), "test.plan.v1.DUTCoverageCondition.Scope.DUT")
	proto.RegisterType((*CodeCoverage)(nil), "test.plan.v1.CodeCoverage")
	proto.RegisterType((*CodeCoverage_Scope)(nil), "test.plan.v1.CodeCoverage.Scope")
}

func init() { proto.RegisterFile("test/plan/v1/plan.proto", fileDescriptor_1a74b4d4119f628f) }

var fileDescriptor_1a74b4d4119f628f = []byte{
	// 525 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xcf, 0x8b, 0xd3, 0x40,
	0x14, 0xc7, 0x49, 0xdb, 0x5d, 0xed, 0x6b, 0x2b, 0xeb, 0x50, 0xb4, 0xb4, 0x20, 0x25, 0x08, 0xf6,
	0xa0, 0x13, 0xb6, 0x9e, 0xa4, 0x88, 0xb2, 0x2d, 0xe2, 0x71, 0xc9, 0xa6, 0x20, 0x5e, 0xca, 0x64,
	0x32, 0x4d, 0x07, 0xd2, 0x4c, 0x98, 0x99, 0x54, 0xfd, 0x9f, 0xfc, 0xa3, 0xbc, 0xf8, 0x47, 0x78,
	0x93, 0x99, 0x24, 0xdb, 0x64, 0xb7, 0xd0, 0xd3, 0xcc, 0xfb, 0xf5, 0x79, 0x6f, 0xbe, 0x7d, 0x0d,
	0xbc, 0xd4, 0x4c, 0x69, 0x2f, 0x4b, 0x48, 0xea, 0x1d, 0xae, 0xed, 0x89, 0x33, 0x29, 0xb4, 0x40,
	0x7d, 0x13, 0xc0, 0xd6, 0x71, 0xb8, 0x1e, 0x5f, 0x25, 0x24, 0xf4, 0x22, 0x76, 0xe0, 0x94, 0x15,
	0xf1, 0xf1, 0x84, 0x64, 0xdc, 0xdb, 0x11, 0x19, 0xfd, 0x20, 0x92, 0x6d, 0xb4, 0xc8, 0x44, 0x22,
	0xe2, 0x5f, 0x65, 0x10, 0x99, 0x60, 0xd3, 0xe7, 0x7e, 0x80, 0xc1, 0x5d, 0xc6, 0x28, 0xdf, 0x72,
	0x4a, 0x34, 0x17, 0x29, 0x9a, 0xc1, 0x85, 0xc1, 0xab, 0x91, 0x33, 0x6d, 0xcf, 0x7a, 0x73, 0x84,
	0xeb, 0x1d, 0xf1, 0x6d, 0x42, 0x52, 0xbf, 0x48, 0x70, 0x57, 0xd0, 0x31, 0x26, 0x42, 0xd0, 0x49,
	0xc9, 0x9e, 0x8d, 0x9c, 0xa9, 0x33, 0xeb, 0xfa, 0xf6, 0x6e, 0x28, 0x79, 0xca, 0xb5, 0x1a, 0xb5,
	0x4e, 0x51, 0xd6, 0x29, 0xd7, 0x7e, 0x91, 0xe0, 0xfe, 0x73, 0xa0, 0x63, 0xec, 0x93, 0x98, 0x1b,
	0x78, 0x66, 0x0a, 0x37, 0x54, 0xa4, 0x11, 0x37, 0xe3, 0x8d, 0x5a, 0x53, 0x67, 0xd6, 0x9b, 0x4f,
	0x9a, 0xbc, 0x80, 0x29, 0xbd, 0xac, 0x52, 0xfc, 0x81, 0xae, 0x9b, 0xe8, 0x1b, 0xbc, 0x88, 0x72,
	0x83, 0x38, 0x30, 0x49, 0x62, 0x56, 0x63, 0xb5, 0x2d, 0xcb, 0x6d, 0xb2, 0x56, 0xeb, 0x60, 0x59,
	0xa6, 0x1e, 0x91, 0xc3, 0x28, 0xd7, 0x8f, 0xbc, 0xe8, 0x13, 0x0c, 0xa8, 0x88, 0xd8, 0x3d, 0x7a,
	0xd4, 0xb1, 0xc0, 0x71, 0x13, 0xb8, 0x14, 0x11, 0xab, 0x6a, 0xfd, 0x3e, 0xad, 0x59, 0x6e, 0x02,
	0x83, 0xc6, 0xe8, 0xe8, 0x15, 0x00, 0xfb, 0x99, 0x49, 0xa6, 0x94, 0x99, 0xaf, 0x50, 0xa2, 0xe6,
	0x19, 0x2f, 0xe0, 0xe2, 0x8e, 0x8a, 0x8c, 0x19, 0xb1, 0x4c, 0x93, 0x4a, 0x2c, 0x73, 0x37, 0xc5,
	0x44, 0x6b, 0xc9, 0xc3, 0x5c, 0xb3, 0x42, 0xf8, 0xae, 0x5f, 0xf3, 0xb8, 0x7f, 0x5b, 0x30, 0x3c,
	0xf5, 0xba, 0xb3, 0x5d, 0x7f, 0xb7, 0xaa, 0xb6, 0x9f, 0xa1, 0x13, 0xe5, 0xba, 0xda, 0x8d, 0xb7,
	0xe7, 0x95, 0xc3, 0xb6, 0xce, 0x84, 0x7c, 0x5b, 0x39, 0xfe, 0xe3, 0x40, 0x7b, 0xb5, 0x0e, 0xd0,
	0x3b, 0x78, 0x92, 0x90, 0x70, 0x13, 0xe5, 0xc5, 0x1b, 0x7a, 0xf3, 0x21, 0x4e, 0x48, 0x88, 0x57,
	0x76, 0x99, 0xd7, 0x69, 0xc4, 0xa4, 0x51, 0xc6, 0xbf, 0x4c, 0x48, 0xb8, 0xca, 0x35, 0x0a, 0xe0,
	0xf9, 0xa3, 0xad, 0x2e, 0x77, 0xe1, 0x0d, 0xa6, 0x3b, 0x29, 0xf6, 0x3c, 0xdf, 0x0b, 0x85, 0xa9,
	0x48, 0xb7, 0x3c, 0xc6, 0x24, 0xe3, 0xf8, 0x6b, 0x99, 0x1f, 0x94, 0xe9, 0xfe, 0xd5, 0xee, 0x81,
	0xa7, 0x41, 0xdd, 0x32, 0xa2, 0x73, 0xc9, 0x54, 0xb9, 0x15, 0xe7, 0xa8, 0x5f, 0xca, 0xf4, 0x23,
	0xb5, 0xf2, 0xb8, 0x01, 0xf4, 0xeb, 0xbf, 0xf9, 0x59, 0x79, 0x5f, 0x57, 0xea, 0x4e, 0xa0, 0xab,
	0x24, 0xdd, 0x64, 0x44, 0xef, 0x0a, 0x89, 0xbb, 0xfe, 0x53, 0x25, 0xe9, 0xad, 0xb1, 0x6f, 0x3e,
	0x7e, 0x5f, 0xc4, 0xe2, 0x7e, 0x28, 0x2c, 0x64, 0xec, 0x1d, 0x27, 0xf4, 0x78, 0xba, 0x95, 0xc4,
	0xb3, 0x7f, 0x69, 0x2f, 0x16, 0x5e, 0xfd, 0xf3, 0xb1, 0x30, 0x67, 0x78, 0x69, 0x63, 0xef, 0xff,
	0x07, 0x00, 0x00, 0xff, 0xff, 0xda, 0x9b, 0xa3, 0xe7, 0x5a, 0x04, 0x00, 0x00,
}
