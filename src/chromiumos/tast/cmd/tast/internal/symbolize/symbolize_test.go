// Copyright 2021 The Chromium OS Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package symbolize

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"

	"chromiumos/tast/cmd/tast/internal/logging"
)

// installFakeGsutil puts a fake, no-op gsutil in the PATH
// and returns a clean up function.
func installFakeGsutil(t *testing.T) func() {
	const (
		path   = "PATH"
		gsutil = "breakpad/testdata/gsutil"
	)

	// Make the fake gsutil executable. This also ensures the file exists.
	err := os.Chmod(gsutil, 0700)
	if err != nil {
		t.Fatalf("cannot chmod gsutil: %q", err)
	}

	gsutilDir, err := filepath.Abs(filepath.Dir(gsutil))
	if err != nil {
		t.Fatalf("cannot find absolute path to the fake gsutil: %q", err)
	}

	origPath := os.Getenv(path)
	os.Setenv(path, gsutilDir+":"+origPath)

	return func() {
		os.Setenv(path, origPath)
	}
}

func TestSymbolize(t *testing.T) {
	cleanUp := installFakeGsutil(t)
	defer cleanUp()

	const crashpadMDMP = "breakpad/testdata/chrome.20210406.155226.62533.9042.dmp"
	tests := []struct {
		desc         string
		minidumpPath string
		buildRoot    string
		builderPath  string
		verifyError  func(*testing.T, error)
		verifyLog    func(*testing.T, *bytes.Buffer)
	}{
		{
			// Dumps generated by breakpad do not require extra parameters.
			desc:         "lsb-release",
			minidumpPath: "breakpad/testdata/abort.20180103.145440.12345.20827.dmp",
		},
		{
			// Show an error, when processing Crashpad dump without additional parameters.
			desc:         "no_lsb-release",
			minidumpPath: crashpadMDMP,
			verifyError: func(t *testing.T, err error) {
				msg := "minidump does not contain release info, please supply --builderpath or --buildroot"
				if err == nil || !strings.Contains(err.Error(), msg) {
					t.Errorf("wanted error containing %q, but got %q", msg, err)
				}
			},
		},
		{
			// When buildroot is supplied, symbols are generated.
			//
			// The directory supplied in the test does not exist,
			// but it doesn't matter - we verify the we tried to generate symbols.
			desc:         "no_lsb-release_buildroot",
			minidumpPath: crashpadMDMP,
			buildRoot:    "/build/root/",
			verifyLog: func(t *testing.T, loggingBuf *bytes.Buffer) {
				if log := loggingBuf.String(); !strings.Contains(log, "Generating 4 symbol file(s) from /build/root/") {
					t.Errorf("expected that symbols would be generated, but it did not happen; log: %q", log)
				}
			},
		},
		{
			// When builder path is supplied, we try to download symbols.
			desc:         "no_lsb-release_builderpath",
			minidumpPath: crashpadMDMP,
			builderPath:  "name-release/R12-34.0.0",
			verifyLog: func(t *testing.T, loggingBuf *bytes.Buffer) {
				if log := loggingBuf.String(); !strings.Contains(log, "Extracting 4 symbol file(s) from gs://chromeos-image-archive/name-release/R12-34.0.0/debug_breakpad.tar.xz") {
					t.Errorf("expected that symbols would be download, but it did not happen; log: %q", log)
				}
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.desc, func(t *testing.T) {
			loggingBuf := bytes.Buffer{}
			cfg := Config{
				Logger: logging.NewSimple(&loggingBuf, false /* datetime */, true /* verbose */),
				// We are using /dev/null to avoid strange effect,
				// when one tests writes symbols and another reads them.
				SymbolDir:   "/dev/null",
				BuildRoot:   tt.buildRoot,
				BuilderPath: tt.builderPath,
			}
			err := SymbolizeCrash(tt.minidumpPath, &bytes.Buffer{}, cfg)

			if tt.verifyError != nil {
				tt.verifyError(t, err)
			} else if err != nil {
				t.Errorf("got error: %q", err)
			}

			if tt.verifyLog != nil {
				tt.verifyLog(t, &loggingBuf)
			}
		})
	}
}
